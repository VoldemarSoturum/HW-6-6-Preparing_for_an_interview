
#===============================================ДЛЯ ЗАДАНИЯ 1
 
class Stack:
    """Простой стек на основе списка Python."""
    def __init__(self):
        # Внутри храним данные в обычном списке Python
        self._data = []

    def is_empty(self) -> bool:
        """Пуст ли стек?"""
        # Если длина списка = 0, значит стек пуст
        return len(self._data) == 0

    def push(self, item) -> None:
        """Положить элемент на верх стека."""
        # Добавляем элемент в конец списка (он же верх стека)
        self._data.append(item)

    def pop(self):
        """Снять верхний элемент и вернуть его.
        Если стек пуст, генерируем исключение.
        """
        if self.is_empty():
            # Пытаемся снять с пустого стека → ошибка
            raise IndexError("pop from empty stack")
        # Метод list.pop() снимает последний элемент
        return self._data.pop()

    def peek(self):
        """Посмотреть верхний элемент без удаления."""
        if self.is_empty():
            # Если стек пуст, верхнего элемента нет → ошибка
            raise IndexError("peek from empty stack")
        # Последний элемент списка — верх стека
        return self._data[-1]

    def size(self) -> int:
        """Текущее количество элементов."""
        # Просто длина списка
        return len(self._data)

    def __repr__(self):
        # Удобное строковое представление для отладки
        return f"Stack({self._data!r})"

#==============================РЕАЛИЗАЦИЯ РЕШЕНИЯ К ЗАДАНИЮ 2, НА ОСНОВЕ ЗАДАНИЯ 1

def is_brackets_balanced(s: str) -> bool:
    """Проверка сбалансированности круглых (), квадратных [] и фигурных {} скобок.

    Алгоритм:
      - Открывающую скобку кладём в стек.
      - На закрывающую: проверяем верх стека.
        Если стек пуст или верхняя скобка не совпадает с парой — ошибка.
        Если совпадает — снимаем из стека.
      - В конце строка правильная, только если стек опустел.
    """
    stack = Stack()
    opens = set("([{")                # множество открывающих скобок
    pair = {')': '(', ']': '[', '}': '{'}  # соответствие закрывающей ↔ открывающей

    for ch in s:
        if ch in opens:
            # Если символ открывающий — кладём в стек
            stack.push(ch)
        elif ch in pair:
            # Если символ закрывающий:
            # 1) стек не должен быть пуст
            # 2) верх стека должен быть той же пары
            if stack.is_empty() or stack.peek() != pair[ch]:
                return False
            # Если всё ок — снимаем верхнюю скобку
            stack.pop()
        else:
            # Если встретили символ, не являющийся скобкой —
            # просто пропускаем (по условию могут быть только скобки, но на всякий случай).
            continue

    # Если стек пуст в конце → все открывающие закрылись
    return stack.is_empty()


def verdict_text(s: str) -> str:
    """Обёртка: возвращает текст вместо True/False."""
    return "Сбалансированно" if is_brackets_balanced(s) else "Несбалансированно"


if __name__ == "__main__":
    # Если запускать файл напрямую:
    
    # Чтобы включить интерактивный ввод и ввести условия проверки, то нужно раскомментировать строки ниже:
    # line = input().strip()
    # print(verdict_text(line))

    # Готовые тесты из условия задачи:

    balanced = [
        "(((([{}]))))",                 # пример 1
        "[([])((([[[]]])))]{()}",       # пример 2
        "{{[()]}}",                     # пример 3
    ]

    unbalanced = [
        "}{}",                          # пример 1
        "{{[(])]}}",                    # пример 2
        "[[{())}]",                     # пример 3
    ]

    print("— Проверка сбалансированных:")
    for s in balanced:
        # Должно напечатать "Сбалансированно"
        print(s, "->", verdict_text(s))

    print("\n— Проверка несбалансированных:")
    for s in unbalanced:
        # Должно напечатать "Несбалансированно"
        print(s, "->", verdict_text(s))
